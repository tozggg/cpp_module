[subject](https://github.com/tozggg/cpp_module/blob/master/cpp_module_04/subject.pdf)
<br>
- 가상 함수
    
    ```cpp
    부모클래스에서 함수에 virtual 붙인다
    = 재정의할 것으로 기대 (오버라이딩)
    = 제일 부모에만 붙여놓아도 자식에서 재선언한 함수는 모두 virtual 취급
    
    만약, 가상함수로 사용하지 않는다면
    어떤 함수가 사용될지 컴파일 단계에서 정해진다
    -> 정적바인딩 (부모=자식 으로 들어오더라도 부모의 함수를 호출) (오버로딩도 여기서 정함)
    
    가상함수로 사용한다면
    어떤 함수가 사용될지 런타임 단계에서 결정
    -> 동적바인딩 (부모=자식 으로 들어오는것에서 값을 보고 함수를 호출할지 결정)
    
    ---------------------------------------------------------------------
    
    // 오버라이딩규칙
    부모 클래스의 함수가 반드시 virtual
    함수의 이름이 같아야함 (소멸자제외)
    인자의 개수와 타입이 같아야함
    상수성(const)이 같아야함
    
    //c++11 부터는 오버라이딩하는 함수의 끝에 override 를 붙여서 오류검출하기
    
    ---------------------------------------------------------------------
    
    // c++ 에서는 업캐스팅, 다운캐스팅시 (포인터)*=new 로 넣는듯 함
    
    > 업캐스팅
    부모* = 자식
    부모변수에 자식을 할당해서 넣기때문에 자식만큼의 공간은 할당되지만 부모까지의 공간만 사용가능
    ! 그러나, virtual 로 선언 했다면 자식의 오버라이딩 된 함수 사용가능
    ! 소멸자도 virtual 해줘야 한다.
    	그렇지 않다면 delete 할때 부모의 소멸자만 호출될 것이다.
    	(원래는 자식->부모 순으로 소멸자 호출되야 함)
    
    > 다운캐스팅
    자식* = 부모
    //오류가 없으려면 명시적형변환이 필요
    실제 동적할당한 메모리보다 뒤의 공간을 강제로 사용할 수 있어 절대 사용하지 않지만
    ㄴ 부모=자식 형태로 할당된 부모변수를 되돌릴때 dynamic_cast<자식*> 으로 쓰곤 한다.
    	 ㄴ 자식만큼 할당되어 있지않아 실패한다면 0을 반환
       ㄴ dynamic_cast 는 런타임중에 이루어짐
    ```
    
- 얕복과 깊복
    - 얕은복사
        - 참조나 주소를 복사할 경우 같은 복사할 대상의 것을 가르키게 복사
        - 자동으로 생성되는 복사생성자나 =연산자오버로딩은 얕은복사
    - 깊은복사
        - 값 자체를 복사해서 사본을 만듬
        - string의 =(대입연산자오버로딩)은 깊은복사

- 순수 가상 함수
    
    ```cpp
    class Parent
    {
    	virtual ~~~ () = 0;
    };
    
    > 부모클래스를 추상클래스로 사용하기 위함
    > 해당 함수를 정의하지 않겠다
    	ㄴ 해당 클래스는 단독 객체로 사용할 수 없다.
    	ㄴ 자식클래스에서 오버라이딩 하겠다 (오버라이딩 하지않으면 자식클래스도 객체생성불가)
    > private 영역에 순수가상함수 선언하여도 원하는 영역에 오버라이딩 가능(의미에맞게)
    
    ```
    
- 인터페이스
    - 순수가상함수만을 보유한 클래스

### ?

- virtual 이지만 =0으로 끝나지 않았다면 반드시 정의? ⇒ o
- 가상소멸자 오버라이딩 받았다면 반드시 선언-정의? ⇒ o
- 복사생성자도 delete 시키고 깊은복사 해야되나? ⇒ 할당연산자만 delete 했음
- 멤버함수에서 자신의 클래스와 동일한 객체를 변수로 사용하는 경우 private 멤버를 접근할 수 있음
    
    ( C++ )
